#This software integrates the MQTT Gateway client and the module for communicating with the NUCLEO-gateway over serial connection.
#Version 1.5, 29/5/2018	
#Major differences from previous version (v1.3): 
#1.  optimization in reading data from serial port (read only required number of bytes)
#2.  do not buffer additional evidence requests from SBA


# consolidated code working with both the DummySBA and Almaviva's SBA.
# Choice between the 2 is made through the command line argument
#run with : python3 forensorGW_v1.5.py --dummySBA True --port /dev/ttyS7 to run with the dummySBA and Nucleo connected to port /dev/ttyS7
#run with : python3 forensorGW_v1.5.py --dummySBA False --port /dev/ttyS7 to run with the Almaviva's SBA and Nucleo connected to port /dev/ttyS7


#This code has not been tested with the SBA 
#Copyright Â© 2017 Synelixis Solutions Ltd 

import serial
import time
import ssl
import datetime
import sys
import random
import json
import base64
import paho.mqtt.client as mqtt

MQTT_qos_level = 2

Protection_level = 0

if (Protection_level == 1):
	ALERT_SIZE = 20 + 32
elif (Protection_level == 2):
	ALERT_SIZE = 20 + 16 + 32 + 3
else:
	ALERT_SIZE = 20


# Parse command line arguments to configure the script

if (len(sys.argv) != 5):
	print("Wrong syntax. Exiting")
	sys.exit(2)

print(sys.argv[1:])

if (sys.argv[1].lower() == "--dummySBA".lower()):
	if (sys.argv[2].lower() == 'True'.lower()):
		DUMMY_SBA = True
	elif (sys.argv[2].lower() == 'False'.lower()):
		DUMMY_SBA = False
	else:
		print("Wrong value for '--dummySBA' parameter. Exiting")
		sys.exit(2)
else:
		print("Wrong syntax.The '--dummySBA' parameter is missing. Exiting")
		sys.exit(2)
	
if (sys.argv[3].lower() == "--port".lower()):
	port = sys.argv[4]
else:
		print("Wrong syntax.The '--port' parameter is missing. Exiting")
		sys.exit(2)
	
	

	
	
	
# Configure the serial connections (the parameters differs on the device you are connecting to)
ser = serial.Serial(
    port,		#ttyS13 corresponds to com14, ttyS12 corresponds to com13 etc.
    baudrate=115200,
    parity=serial.PARITY_NONE,
    stopbits=serial.STOPBITS_ONE,
    bytesize=serial.EIGHTBITS, 
	timeout=10	#it was 20 previously. Before the demo in Brussels it was 5, latest value was 8
)


#the following parameters are for testing with ALMAVIVA's MQTT broker
if DUMMY_SBA is False:
#work with remote broker
	MQTT_server_address = "5.175.49.133"
	MQTT_server_user_name = "user"
	MQTT_server_passwd = "NdPsd7423!"
	MQTT_server_port = 8883		#8883 is the default port for the MQTT broker when working with security

#the following parameters are for testing with SYN's mosquitto MQTT broker
elif DUMMY_SBA is True:
	MQTT_server_address = "127.0.0.1"
	MQTT_server_user_name = ""
	MQTT_server_passwd = ""
	MQTT_server_port = 1883		#1883 is the default port for the MQTT broker

#define MQTT topics
MQTT_topic_alert = "gwy/alert"
MQTT_topic_evidence = "gwy/evidenceresponse"
MQTT_topic_evidence_request = "gwy/evidencerequest"
MQTT_topic_gateway_status_request = "gwy/statusgatewayrequest"
MQTT_topic_gateway_status_response = "gwy/statusgatewayresponse"
MQTT_topic_node_status_request = "gwy/statusnoderequest"
MQTT_topic_node_status_response = "gwy/statusnoderesponse"
MQTT_topic_evidence_list = "gwy/evidencelist"
MQTT_topic_node_reset_request = "gwy/resetnoderequest"
MQTT_topic_node_poweron_notification = "gwy/nodepoweron"
MQTT_topic_node_status_request_from_WSN_GUI = "gwy/nodestatusrequest4wsnGUI"
MQTT_topic_node_status_response_for_WSN_GUI = "gwy/nodestatusresponse4wsnGUI"
MQTT_topic_ask_node_for_alert_request = "gwy/asknodeforalertrequest"




evidence_file_input = "NUCLEO_gateway_output.jpg"

parsed_received_json={}
alert_timestamps = [0, 0]		#2-element array holding the timestamp of the alerts to be used as timestamps for the subsequent evidence from the same node. 
							#Timestamps in the current version are generated by the gateway. In later versions they will come from the SecSoc 

clear_to_send_ev_request_to_nucleo_gateway = 1		#1 means that an evidence request coming from broker can be relayed to the sensor network (i.e. burst transmission not in progress)

global evidence_items_sent
evidence_items_sent = [0, 0]	#evidence items transmitted from each node
global alert_items_sent
alert_items_sent = [0, 0]	#evidence items transmitted from each node
global management_requests_received_from_SBA
management_requests_received_from_SBA = 0
global management_requests_sent_to_WSN
management_requests_sent_to_WSN = 0
global full_status_response_indication
full_status_response_indication = 1
global management_responses_received_from_WSN
management_responses_received_from_WSN = 0
global alerts_from_VSN
alerts_from_VSN = 0
global evidence_items_from_VSN
evidence_items_from_VSN = 0
global total_evidence_bytes_from_VSN
total_evidence_bytes_from_VSN = 0


global requestId
time.sleep(1) 


# Callback that is executed when we disconnect from the broker.
def onDisconnect(client, userdata, msg):
   print("Disconnected from the broker")	


# Callback that is executed when subscribing to a topic
def onSubscribe(client, userdata, mid, granted_qos):
	print('F-GW subscribed on FORENSOR MQTT topic')
	

# The callback for when the client receives a CONNACK response from the server.
def onConnect(client, userdata, flags, rc):
	print("Connected to MQTT Broker " + MQTT_server_address + " with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
	#Gateway subscribes only to evidence request topic
	client.subscribe(MQTT_topic_evidence_request, MQTT_qos_level)		# topic, QoS. 
	client.subscribe(MQTT_topic_gateway_status_request, MQTT_qos_level)
	client.subscribe(MQTT_topic_node_status_request, MQTT_qos_level)
	client.subscribe(MQTT_topic_node_reset_request, MQTT_qos_level)
	client.subscribe(MQTT_topic_node_status_request_from_WSN_GUI, MQTT_qos_level)
	client.subscribe(MQTT_topic_ask_node_for_alert_request, MQTT_qos_level)
	
	
	
def decodeNucleoOutput(buffer, length):
	decoded_buffer = []
	#print("inside decodeNucleoOutput function: the length is " + str(length))
	for i in range(length//2):
		decoded_buffer.append((int(buffer[2*i]) - 0x30) + ((int(buffer[2*i+1]) - 0x30) << 4))
	return decoded_buffer   
	
	

# The callback for when a PUBLISH message is received from the server.
def onMessage(client, userdata, msg):
	global parsed_received_json
	global clear_to_send_ev_request_to_nucleo_gateway
	global requestId
	global management_requests_received_from_SBA
	global management_requests_sent_to_WSN
	global full_status_response_indication
	global management_responses_received_from_WSN
	global alert_items_sent
	global evidence_items_sent
	print("")
	print("Message received from broker")
	print("Message topic: " + msg.topic)
	print("Message payload: ")
	print(str(msg.payload.decode("utf-8")))	#decoding is used to get rid of the 'b' prefix and the single quotes
	received_json_data = msg.payload.decode('utf-8')
	parsed_received_json = json.loads(received_json_data)
	
	#implement here the code that sends the evidence to the broker 
	if (msg.topic == MQTT_topic_evidence_request):		#we received an evidence request from the SBA
		print("This is an evidence request message. Parsing...")
		gatewayId = parsed_received_json['gatewayId']
		nodeId = parsed_received_json['nodeId']
		alert_id = parsed_received_json['alertId']
		minConfidenceLevel = parsed_received_json['minConfidenceLevel']
		requestId = parsed_received_json['requestId']	#added on 2/3/2017 to parse the requestId included in the evidence request message
		
		print("Gateway is " + str(gatewayId))
		print("NodeId is " + str(nodeId))
		print("AlertId is " + str(alert_id))
		print("Min conf level is " + str(minConfidenceLevel))
		print("Request Id is " + str(requestId))
		
		
		#sys.stdout.flush()		#maybe it is not needed. The code has been tested with this and works OK.
		
		if (clear_to_send_ev_request_to_nucleo_gateway == 1):
		#notifying the NUCLEO gateway by sending evidence request over the serial port
			
			
			#test_string_to_write_to_serial = "hello\n"
			#ser.write("hello hello\n".encode())
			ser.write("\x32".encode())		#Type: evidence request #this works for sending the character 1. ser.write("1".encode()). With fgetc in Contiki the receiver gets 49
			#time.sleep(3)					#in previous version 1.4 it was sleep(2)
			ser.write("\x30".encode())
			ser.write(bytes([(gatewayId & 0x0F) + 0x30]))			#gatewayId
			ser.write(bytes([(gatewayId >> 4) + 0x30]))
			ser.write(bytes([(nodeId & 0x0F) + 0x30]))				#nodeId
			ser.write(bytes([(nodeId >> 4) + 0x30]))
			ser.write(bytes([(alert_id & 0x0F) + 0x30]))				#alertId - low byte
			ser.write(bytes([((alert_id & 0xFF) >> 4) + 0x30]))
			ser.write(bytes([((alert_id >> 8) & 0x0F) + 0x30]))				#alertId - high byte
			ser.write(bytes([(alert_id >> 12) + 0x30]))
			
			ser.write(bytes([(minConfidenceLevel & 0x0F) + 0x30]))				#minConfidenceLevel
			ser.write(bytes([(minConfidenceLevel >> 4) + 0x30]))
			ser.write("\n".encode())
#added on 21/5/2017
#			ser.write("\n".encode()) #or test also ser.write(b"2\n")
#			ser.write(b"2\n")
			
			#ser.flush()
			clear_to_send_ev_request_to_nucleo_gateway = 0	#from now on no more evidence transmission requests can be relayed to the sensor network
			print("Evidence request message SENT to nucleo gateway for node " + str(nodeId))
		else:
		#the evidence request cannot be forwarded to WSN because an evidence transfer is in progress
			print("Evidence request message for node " + str(nodeId) + " is ignored because another evidence transfer is in progress inside WSN")
			
		
			
	elif (msg.topic == MQTT_topic_gateway_status_request):		#we received a gateway status request from the SBA
		
		management_requests_received_from_SBA = management_requests_received_from_SBA +1
		print("This is a gateway status request message. Parsing...")
		gatewayId = parsed_received_json['gatewayId']
		requestId = parsed_received_json['requestId']	
		full_status_response_indication = parsed_received_json['fullStatus']
		print("Gateway is " + str(gatewayId))
		print("Request Id is " + str(requestId))
		print("Full status is " + str(full_status_response_indication))
		

		#read gateway parameters and status - for now it is simulated
		
		#prepare the gateway status response
		gateway_status_response_msg=dict()
		gateway_status_response_msg['gatewayId'] = gatewayId
		ts = time.time()	# ts is the time returned in seconds
		st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%dT%H:%M:%S+02:00')
		gateway_status_response_msg['statusTime'] = st	
				
		gateway_status_response_msg['gatewayLocation'] = dict()
		gateway_status_response_msg['gatewayLocation']['latitude'] = 40.568002		
		gateway_status_response_msg['gatewayLocation']['longitude'] = 23.104144
		
		gateway_status_response_msg['operationalStatus'] = 1
		gateway_status_response_msg['requestId'] = requestId
		gateway_status_response_msg['vsnNetInterfaceStatus'] = 1
		gateway_status_response_msg['numberNeighbourNode'] = 2
		#full_status_response_indication = random.randint(0, 1)
		if (full_status_response_indication == 1):
			gateway_status_response_msg['fullStatus'] = 1
			gateway_status_response_msg['ipPktsRx'] = 1*alerts_from_VSN + int(total_evidence_bytes_from_VSN/96.0)
			gateway_status_response_msg['ipPktsTx'] = alerts_from_VSN + evidence_items_from_VSN*2
			gateway_status_response_msg['ipPktsLossRate'] = 0
			gateway_status_response_msg['numberCollision'] = 0
			gateway_status_response_msg['dataRateTx'] = 5
			gateway_status_response_msg['dataRateRx'] = 5
			gateway_status_response_msg['alertsItemsRx'] = alerts_from_VSN
			gateway_status_response_msg['evidencesItemsRx'] = evidence_items_from_VSN
			gateway_status_response_msg['managReqTx'] = management_requests_sent_to_WSN
			gateway_status_response_msg['managResRx'] = management_responses_received_from_WSN
			gateway_status_response_msg['managReqRx'] = management_requests_received_from_SBA
		else:
			gateway_status_response_msg['fullStatus'] = 0
		
		#prepare the json message and publish it
		#json.dumps() method turns a Python data structure into JSON:
		transmitted_jsonData = json.dumps(gateway_status_response_msg)
		print("the published JSON data for gateway status response are:")
		print("")
		print(transmitted_jsonData)
		with open('transmitted_JSONData_gateway_status_response.json', 'w') as f:
			json.dump(transmitted_jsonData, f)
		f.close()
		mqttc.publish(MQTT_topic_gateway_status_response, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);
		
	elif (msg.topic == MQTT_topic_node_status_request):		#we received a node status request from the SBA
		
		management_requests_received_from_SBA = management_requests_received_from_SBA +1
		print("This is a node status request message. Parsing...")
		gatewayId = parsed_received_json['gatewayId']
		requestId = parsed_received_json['requestId']	
		nodeId = parsed_received_json['nodeId']
		full_status_response_indication = parsed_received_json['fullStatus']
		print("Gateway is " + str(gatewayId))
		print("Request Id is " + str(requestId))
		print("Node Id is " + str(nodeId))
		print("Full status id is " + str(full_status_response_indication))
		management_requests_sent_to_WSN = management_requests_sent_to_WSN + 1
		
		if (clear_to_send_ev_request_to_nucleo_gateway == 1):
		#notifying the NUCLEO gateway by sending node reset request over the serial port
			
			
			ser.write("\x35".encode())		#Type: evidence request #this works for sending the character 1. ser.write("1".encode()). With fgetc in Contiki the receiver gets 49
			#time.sleep(3)					#in previous version 1.4 it was sleep(2)
			ser.write("\x30".encode())
			ser.write(bytes([(gatewayId & 0x0F) + 0x30]))			#gatewayId
			ser.write(bytes([(gatewayId >> 4) + 0x30]))
			ser.write(bytes([(nodeId & 0x0F) + 0x30]))				#nodeId
			ser.write(bytes([(nodeId >> 4) + 0x30]))
			ser.write("\n".encode())
			print("Node status request message SENT to nucleo gateway for node " + str(nodeId))

		else:
			print("Node status Request cannot now be sent to the WSN ...")
		
		
		
	
	elif (msg.topic == MQTT_topic_node_reset_request):		#we received a node reset request from the SBA

		print("This is a node reset request message. Parsing...")
		gatewayId = parsed_received_json['gatewayId']
		nodeId = parsed_received_json['nodeId']
		requestId = parsed_received_json['requestId']	#requestId included in the node reset request message
		
		print("Gateway is " + str(gatewayId))
		print("NodeId is " + str(nodeId))
		print("Request Id is " + str(requestId))
		
		
		if (clear_to_send_ev_request_to_nucleo_gateway == 1):
		#notifying the NUCLEO gateway by sending node reset request over the serial port
			
			
			ser.write("\x34".encode())		#Type: evidence request #this works for sending the character 1. ser.write("1".encode()). With fgetc in Contiki the receiver gets 49
			#time.sleep(3)					#in previous version 1.4 it was sleep(2)
			ser.write("\x30".encode())
			ser.write(bytes([(gatewayId & 0x0F) + 0x30]))			#gatewayId
			ser.write(bytes([(gatewayId >> 4) + 0x30]))
			ser.write(bytes([(nodeId & 0x0F) + 0x30]))				#nodeId
			ser.write(bytes([(nodeId >> 4) + 0x30]))
			ser.write("\n".encode())
			print("Node reset request message SENT to nucleo gateway for node " + str(nodeId))

		else:
			print("Node Reset Request cannot now be sent to the WSN ...")
	


	elif (msg.topic == MQTT_topic_node_status_request_from_WSN_GUI):		#we received a node reset request from the SBA

		print("This is a limited node status request message. Parsing...")
		gatewayId = parsed_received_json['gatewayId']
		nodeId = parsed_received_json['nodeId']
		requestId = parsed_received_json['requestId']	#requestId included in the node reset request message
		
		print("Gateway is " + str(gatewayId))
		print("NodeId is " + str(nodeId))
		print("Request Id is " + str(requestId))
		
		
		if (clear_to_send_ev_request_to_nucleo_gateway == 1):
		#notifying the NUCLEO gateway by sending node reset request over the serial port
			
			
			ser.write("\x35".encode())		#Type: evidence request #this works for sending the character 1. ser.write("1".encode()). With fgetc in Contiki the receiver gets 49
			#time.sleep(3)					#in previous version 1.4 it was sleep(2)
			ser.write("\x30".encode())
			ser.write(bytes([(gatewayId & 0x0F) + 0x30]))			#gatewayId
			ser.write(bytes([(gatewayId >> 4) + 0x30]))
			ser.write(bytes([(nodeId & 0x0F) + 0x30]))				#nodeId
			ser.write(bytes([(nodeId >> 4) + 0x30]))
			ser.write("\n".encode())
			print("Node status request message SENT to nucleo gateway for node " + str(nodeId))

		else:
			print("Node status Request cannot now be sent to the WSN ...")


	elif (msg.topic == MQTT_topic_ask_node_for_alert_request):		#we received an ask node for alert request from the SBA - it is used for testing purposes

		print("This is an ask node for alert request message. Parsing...")
		gatewayId = parsed_received_json['gatewayId']
		nodeId = parsed_received_json['nodeId']
		requestId = parsed_received_json['requestId']	#requestId included in the node reset request message
		
		print("Gateway is " + str(gatewayId))
		print("NodeId is " + str(nodeId))
		print("Request Id is " + str(requestId))
		
		
		if (clear_to_send_ev_request_to_nucleo_gateway == 1):
		#notifying the NUCLEO gateway by sending node reset request over the serial port
			
			
			ser.write("\x36".encode())		#Type: evidence request #this works for sending the character 1. ser.write("1".encode()). With fgetc in Contiki the receiver gets 49
			#time.sleep(3)					#in previous version 1.4 it was sleep(2)
			ser.write("\x30".encode())
			ser.write(bytes([(gatewayId & 0x0F) + 0x30]))			#gatewayId
			ser.write(bytes([(gatewayId >> 4) + 0x30]))
			ser.write(bytes([(nodeId & 0x0F) + 0x30]))				#nodeId
			ser.write(bytes([(nodeId >> 4) + 0x30]))
			ser.write("\n".encode())
			print("Ask Node for alert request message SENT to nucleo gateway for node " + str(nodeId))

		else:
			print("Ask Node for Alert Request cannot now be sent to the WSN ...")
			
			
			
	
print("Before configuring the MQTT client ...")	
mqttc = mqtt.Client(client_id='FORENSOR_gateway', clean_session=False)	#the parameters can be omitted. Previously it was clean_session=True
mqttc.on_connect = onConnect
mqttc.on_message = onMessage
mqttc.on_subscribe = onSubscribe
mqttc.on_disconnect = onDisconnect

mqttc.username_pw_set(MQTT_server_user_name, password = MQTT_server_passwd)

#added for supporting MQTT security. Put to "True" to test with secure MQTT
if DUMMY_SBA is False:
	mqttc.tls_set("Mqtt Client Secrets/caroot.pem",
               "Mqtt Client Secrets/client-cert.pem",
               "Mqtt Client Secrets/client-key.pem", cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1, ciphers=None)	#was cert_reqs=ssl.CERT_REQUIRED

	# disables peer verification
	mqttc.tls_insecure_set(False)	#False
	mqttc.connect("test.broker.local", MQTT_server_port, 60)
#end of code added for supporting security
else:
	#the following should be included for MQTT communications without security (i.e. with dummySBA)
	mqttc.connect(MQTT_server_address, MQTT_server_port, keepalive=60, bind_address="")
	
print("End configuring the MQTT client ...")	
	


mqttc.loop_start()		#this is for not blocking monitoring of network traffic	

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
#mqttc.loop_forever()
ser.flushInput()		#this is needed to delete all characters from the serial input buffer (corresponding to already buffered data from previous transaction)
#time.sleep(10) 

#included for testing the interrupt-based reception over serial port at the nucleo side 
#print("writing to serial port")
#ser.write(b'hello')

if False:
	update_alert_msg=dict()
	update_alert_msg['evidenceId'] = 4
	update_alert_msg['nodeId'] = 2
	update_alert_msg['alertId'] = 1
	update_alert_msg['gatewayId'] = 0
	ts = time.time()	# ts is the time returned in seconds
	st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%dT%H:%M:%S+02:00')
	update_alert_msg['timestamp'] = st
	update_alert_msg['confidenceLevel'] = 8

	transmitted_jsonData = json.dumps(update_alert_msg)
	print("the published JSON data for node status response are:")
	print("")
	print(transmitted_jsonData)
	mqttc.publish(MQTT_topic_update_alert, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);


while True :
		#mqttc.loop(timeout = 1.0)		#according to documentation the other parameter max_packets is obsolete
		
		
		sys.stdout.flush()
		#time.sleep(1)
        #out = ''
        # let's wait one second before reading output (let's give device time to answer)
        #time.sleep(1)
        #while ser.inWaiting() > 0:
         #   out += ser.read(1)

        #if out != '':
        #    print ">>" + out
		
		#print("Inside while loop waiting for message to receive")
		response = ser.readline()	#it works OK
		#print("received: " + str(response))	#.decode(encoding='ascii'))
		#out = str(response)	#.decode(encoding='ascii')		#it works OK
		#print(out)
		
		print(">> " + response.decode('ascii', 'ignore'))
		out = response.decode('ascii', 'ignore')
		#ser.flushOutput()		#it doesn't produce an error but check if this is needed at this point!!!!!!!!!!
		
		#if (out.startswith("b'dumping")):	#it works OK	
		#also tested with out.startswith("b'dumping binary data\n'")
			#print (out == ' unicast message received from 9.0:\n')
			#print("we received the required data: " + response.decode())
			#print("we received the required data: ")
			#print(response.decode())
			
		if (out.startswith('F-GW: Sending alert notification')):
			#print (out == 'GATEWAY:sending alert notification\n')		#it prints TRUE if the sentence we received starts with the given text
			#print("we received the required data: " + response.decode())
			#print("we received an alert: ")
			#print(response.decode())
			
			response = ser.readline()		#it will return 2*20 bytes and 2*52 bytes for the case of protection level 1
			print(">> " + response.decode('ascii', 'ignore'))
			#print(">> the size of the response is " + str(len(response)) + " and the size of alert is " + str(2*ALERT_SIZE))
			decoded_response = decodeNucleoOutput(response, 2*ALERT_SIZE)	#the decoded output is stored in array response which has size ALERT_SIZE bytes
			nucleo_command = decoded_response[0]
			print("nucleo_command is  " + str(nucleo_command))
			
			#code for reading the alert coming from NUCLEO
			#out =ser.read(1)	#the output is a string!!!
			#print(ord(out.decode()))	#ord parses a single-byte string and returns int. It works here
			#print(out[0])
			
			if (nucleo_command == 1):
				print ("Receiving alert from NUCLEO gateway...")
				#out =ser.read(20)		#read 20 more bytes from input
				#print(out[0])	it works
				#print(out[1])	it works
				#we have to include also the message type
				gatewayId = decoded_response[1]
				decoded_response = decoded_response[2:]		#cut first 2 bytes from "out" - this is done to remove the nucleo_command byte and the gatewayID byte
				if (Protection_level == 2):		#parse the IV
					IV = decoded_response[:16]
					decoded_response = decoded_response[16:]		#cut first 16 bytes from "out"
					print("the IV is " )
					for i in range(0,16):
						print(IV[i])
				
				
				nodeId = decoded_response[0]
				messageType = decoded_response[1]
				alert_id = decoded_response[2] + (decoded_response[3]<<8)
				confidenceLevel  = decoded_response[4]
				if (Protection_level != 2):
					#alertTime coming from sensor - 4 bytes
					alertTime = decoded_response[5] + (decoded_response[6]<<8) + (decoded_response[7]<<16) + (decoded_response[8]<<24)
					#latitude 
					latitude = decoded_response[9] + (decoded_response[10]<<8) + (decoded_response[11]<<16) + (decoded_response[12]<<24)
					#longitude
					longitude = decoded_response[13] + (decoded_response[14]<<8) + (decoded_response[15]<<16) + (decoded_response[16]<<24)
					eventType = decoded_response[17]
					print ("Alert id: " + str(alert_id) + ", Gateway id: " + str(gatewayId) + ", Node Id: " + str(nodeId) + ", Event Type: " + str(eventType) + ", Latitude: " + str(latitude) + ", Longitude: " + str(longitude) + ", Alert Time: " + str(alertTime) + ", Confidence Level: " + str(confidenceLevel))
				
				else:
					decoded_response = decoded_response[5:]		#cut the first 5 bytes
				alerts_from_VSN = alerts_from_VSN + 1
				if (Protection_level != 0):
					#print ("HMAC: " + str(str.encode(decoded_response[-32:])))
					encoded_HMAC_string = base64.b64encode((bytes(decoded_response[-32:])))		#keep only the last 32 bytes
					decoded_response = decoded_response[:-32]		#cut the last 32 bytes
					
				#*************************************************************************************************************************************					
				#create the time of the alert in ISO format. Alert time is the time the alert was received at the gateway
				ts = time.time()	# ts is the time returned in seconds
				st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%dT%H:%M:%S+02:00')
				#store the timestamp to be used later for the timestamp of evidence
				if (nodeId == 2):		#the timestamp value for sensor 11 goes to the first position of the array
					alert_timestamps[0] = st
					alert_items_sent[0] = alert_items_sent[0] + 1
				else:
					alert_timestamps[1] = st
					alert_items_sent[1] = alert_items_sent[1] + 1
				#*************************************************************************************************************************************	
				
				#create alert message
				alert_msg=dict()	
				alert_msg['gatewayId'] = gatewayId
				alert_msg['nodeId'] = nodeId
				alert_msg['messageType'] = messageType
				alert_msg['id'] = alert_id			#identifier e.g. sequence number of alert
				alert_msg['confidenceLevel'] = confidenceLevel
				
				if (Protection_level != 0):
					alert_msg['hmacSignature'] = str(encoded_HMAC_string.decode("utf-8"))
				
				if (Protection_level != 2):
					alert_msg['timestamp'] = alertTime
					#include the following in other field of json to get accurate time before GPS is integrated in the sensor node
					#alert_msg['timestamp'] = st		
					alert_msg['location'] = dict()
					alert_msg['location']['latitude'] = latitude		#for Athens it is 37.9794500, for Rome it is 41.8919300, for thermi1 it is 40.568002
					alert_msg['location']['longitude'] = longitude		#for Athens it is 23.7162200, for Rome it is 12.5113300, for thermi1 it is 23.104144
					#datetime.datetime.now().isoformat() it doesn't work correctly with SBA because it also includes milliseconds 	#'2016-09-20T23:20:50+02:00'
					alert_msg['eventType'] = eventType		#1 for person walking
					
				
				else:
					#the encryptedData field holds timestamp, latitude, longitude, and event (with possible padding)
					alert_msg['encryptedData'] = str((base64.b64encode(bytes(decoded_response))).decode("utf-8"))
					alert_msg['initializationVector'] = str((base64.b64encode(bytes(IV))).decode("utf-8"))
					
				#prepare the json message and publish it
				#json.dumps() method turns a Python data structure into JSON:
				transmitted_jsonData = json.dumps(alert_msg)
				print("")
				print("The published JSON data for alert sent are:")
				print(transmitted_jsonData)
				# Writing JSON data into a file called transmitted_JSONData.json
				#Use the method called json.dump()
				#It's just dump() and not dumps()
				#Encode JSON data
				with open('transmitted_JSONData_alert.json', 'w') as f:
					json.dump(transmitted_jsonData, f)
				f.close()
				#send the alert
				mqttc.publish(MQTT_topic_alert, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);
				print("")
				print ("Alert sent to broker")
				
				
				
				#END of sending alert to SBA through broker
				
				

#*********************************************END of testing code for sending update list of evidences to SBA through broker (evidence list)
				
				
				
				
				
		elif (out.startswith('F-GW: Dumping binary data')):
			#print (out == 'GATEWAY:dumping binary data\n')		#it prints TRUE is the sentence we received starts with the given text
			#print("we received the required data: " + response.decode())
			#ser.flushInput()		#this is needed to delete all characters from the serial input buffer.
			#print("we received the required evidence: ")
			#print(response.decode())
			
			#out =ser.readline()	#was evidence_size
			#with open(evidence_file_input, 'w') as f:		#access rights were 'a+b'
					
				#for x in range(1, 100):		#it was while 1:
				#	out += ser.read(1)							#it was out =ser.read(ser.inWaiting())
			#	f.write(out.decode('ascii', 'ignore'))
			#f.close()
			ser.write(b'OK\n')	#tell the nucleo that we are ready to read data over the serial port
			ser.readline()		#this is for clearing the input buffer from the message/line sent by the nucleo from the echo of the serial port process (saying received line: %s\n)
			#code for reading the evidence coming from NUCLEO
			out =ser.read(1)	#the output is a string!!!
			#print(ord(out.decode()))	#ord parses a single-byte string and returns int. It works here
			#print(out[0])
			
			if (out[0] == 3):
				print ("Receiving evidence from NUCLEO")
				out =ser.read(3)		#read 10 more bytes from input - changed to 6 to take into account the fact that the evidence time has been included in the evidence item - changed to 3 on 20/9/2017
				#print(out[0])	it works
				#print(out[1])	it works
				gatewayId = out[0]
				evidence_size = out[1] + (out[2]<<8) 
				#evidence_id = out[2] 		#-1 is included so that evidence id starts from 0
				
				#nodeId = out[4]
				#alertId = out[5]
				#evidenceTime = out[6] + (out[7]<<8) + (out[8]<<16) + (out[9]<<24)	the evidenceTime data are transmitted as part of the evidence container
				
				
				
				#this prints out the value of the first byte received print(out.decode()[0])
				#the whole evidence item is stored in the gateway
				#bytes_read = 0;
				with open(evidence_file_input, 'wb') as f:		#access rights were 'a+b'
					#while bytes_read<35000:
					#	bytesToRead = ser.inWaiting()
					#	out +=ser.read(bytesToRead)
					#	bytes_read +=bytesToRead
					#	print("I read " + str(bytesToRead) + " bytes")
					
					out =ser.read(evidence_size)
				#for x in range(1, 100):		#it was while 1:
				#	out += ser.read(1)							#it was out =ser.read(ser.inWaiting())
					f.write(out)
				f.close()
				
				#parse the contents of the evidence item to construct the JSON
				#for protection levels 0 and 1 the content field in JSON contains the image
				#for protection level 2 the encryptedData field in JSON contains timestamp, latitude, longitude, image and padding
				if (Protection_level == 2):		#parse the IV
					IV = out[:16]
					out = out[16:]		#cut first 16 bytes from "out"
					print("the IV is " )
					for i in range(0,16):
						print(IV[i])
				
				#in all protection levels the following fields are in place
				nodeId = out[0]
				messageType = out[1]
				alertId = out[2] + (out[3]<<8) 
				evidence_id = out[4] + (out[5]<<8)
				contentType = out[6]
				errorCode = out[7]	
				
				out = out[8:]	#cut first 8 bytes from the updated (in case of protection level 2) "out"
				
				print ("Evidence size: " + str(evidence_size) + ", Evidence id: " + str(evidence_id) + ", Gateway Id: " + str(gatewayId) + ", Node Id: " + str(nodeId) + ", Alert Id: " + str(alertId) + ", Content type: " + str(contentType) + ", Error code: " + str(errorCode))
				
				
				#update statistics
				time.sleep(1) 
				evidence_items_from_VSN = alerts_from_VSN + 1
				total_evidence_bytes_from_VSN = total_evidence_bytes_from_VSN + evidence_size
				
				if (Protection_level != 0):
					evidenceMAC = out[-32:]
					print("the evidence MAC is " )
					for i in range(0,32):
						print(evidenceMAC[i])
					out = out[:-32]		#cut the last 32 bytes
				#now out holds timestamp, latitude and longitude, image (plus possible padding in case of security level 2)
				
				if (Protection_level != 2):
					evidenceTime = out[0] + (out[1]<<8) + (out[2]<<16) + (out[3]<<24)
					#latitude 
					latitude = out[4] + (out[5]<<8) + (out[6]<<16) + (out[7]<<24)
				
					#longitude
					longitude = out[8] + (out[9]<<8) + (out[10]<<16) + (out[11]<<24)
					out = out[12:]
					
				#out now holds the image (plus possible padding in case security level 2 is used)
				
				
				#prepare EVIDENCE MESSAGE to send. The evidence image has been previously stored in file evidence_file_input
				#with open(evidence_file_input, 'rb') as evidence_file:
				#	encoded_image_string = base64.b64encode(evidence_file.read())
				#evidence_file.close()
				
				
				#create the evidence response to be sent to the broker. Evidence time is the time of the associated alert (previously stored in array alert_timestamps)
				evidence_response_msg=dict()
				evidence_response_msg['id'] = evidence_id			#identifier e.g. sequence number of evidence data
				evidence_response_msg['gatewayId'] = gatewayId
				evidence_response_msg['nodeId'] = nodeId
				evidence_response_msg['alertId'] = alertId
				evidence_response_msg['requestId'] = requestId
				evidence_response_msg['errorCode'] = errorCode
				evidence_response_msg['messageType'] = messageType
				#create the time of the alert in ISO format. Received timestamp is the time the alert was received at the gateway
				ts = time.time()	# ts is the time returned in seconds
				st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%dT%H:%M:%S+02:00')

				evidence_response_msg['receivedTimestamp'] = st
				
				
				#added fields from latest json schema
				evidence_response_msg['confidenceLevel'] = 5	#probably it is not needed
				evidence_response_msg['contentType'] = chr(contentType)			#"enum": ["i", "f", "v"] passed through the chr() function to transmit character instead of the ASCII value
				#here previously were commands to populate the evidence timestamp structures
				
				if (Protection_level != 0):
					#send the MAC in base64 encoding
					evidence_response_msg['hmacSignature'] = str((base64.b64encode(evidenceMAC)).decode("utf-8"))
				
				
				
				if (Protection_level != 2):
					evidence_response_msg['evidenceTime'] = dict()
					evidence_response_msg['evidenceTime']['startTimestamp'] = evidenceTime
					evidence_response_msg['location'] = dict()
					evidence_response_msg['location']['latitude'] = latitude
					evidence_response_msg['location']['longitude'] = longitude
					#the content field holds only the image (base64-encoded)
					evidence_response_msg['content'] = str((base64.b64encode(out)).decode("utf-8"))
				else:
					#the encryptedData field holds timestamp, latitude, longitude, and image (with possible padding)
					evidence_response_msg['encryptedData'] = str((base64.b64encode(out)).decode("utf-8"))
					evidence_response_msg['initializationVector'] = str((base64.b64encode(IV)).decode("utf-8"))
					
				
				
				#prepare the json message and publish it
				#json.dumps() method turns a Python data structure into JSON:
				transmitted_jsonData = json.dumps(evidence_response_msg)
				print("Sending JSON data for evidence response to MQTT broker")
				print("")
				#print(transmitted_jsonData)
				# Writing JSON data into a file called transmitted_JSONData.json
				#Use the method called json.dump()
				#It's just dump() and not dumps()
				#Encode JSON data
				with open('transmitted_JSONData_evidence.json', 'w') as f:
					json.dump(transmitted_jsonData, f)
				f.close()	
				#send the evidence
				mqttc.publish(MQTT_topic_evidence, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);
				
				
				#allow relaying of evidence transmission requests to the wireless sensor network
				clear_to_send_ev_request_to_nucleo_gateway = 1
				

				if (nodeId == 2):		#the timestamp value for sensor 11 goes to the first position of the array
					evidence_items_sent[0] = evidence_items_sent[0] + 1
				else:
					evidence_items_sent[1] = evidence_items_sent[1] + 1
########################################################################################################################
		elif (out.startswith('F-GW: Sending node appearance event')):
			response = ser.readline()		 
			print(">> " + response.decode('ascii', 'ignore'))
			decoded_response = decodeNucleoOutput(response, 2*4)	#the decoded output is stored in array response which has size 4 bytes
			nucleo_command = decoded_response[0]
			print("nucleo_command is  " + str(nucleo_command))
			gatewayId = decoded_response[1]
			nodeId = decoded_response[2]
			preferredParentId = decoded_response[3]
			#prepare node appearance message to send to the SBA
			node_appearance_msg=dict()	
			node_appearance_msg['gatewayId'] = gatewayId
			node_appearance_msg['nodeId'] = nodeId
			node_appearance_msg['preferredParentId'] = preferredParentId
			
			transmitted_jsonData = json.dumps(node_appearance_msg)
			mqttc.publish(MQTT_topic_node_poweron_notification, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);
			print("")
			print ("Notification for node power on sent to broker")
########################################################################################################################			
		elif (out.startswith('F-GW: Sending node status reply')):
			response = ser.readline()		#it will return 
			print(">> " + response.decode('ascii', 'ignore'))
			print("size of received response is " + str(len(response)))
			print("will decode for " + str(2*44 + 2*16*((len(response) - 2*44)//(2*16))) + " characters") 
			decoded_response = decodeNucleoOutput(response, 2*44 + 2*16*((len(response) - 2*44)//(2*16)))	#the decoded output is stored in array response which has size 4 bytes
			nucleo_command = decoded_response[0]
			print("nucleo_command is  " + str(nucleo_command))
			gatewayId = decoded_response[1]
			nodeId = decoded_response[2]
			preferredParentId = decoded_response[38] + (decoded_response[39]<<8)
			no_of_neighbors = decoded_response[7]
			print(str(nodeId) + "'s preferred parent is " + str(preferredParentId))
			
			#this is for the limited node status reply - tested with the dummy SBA
			node_status_msg=dict()	
			node_status_msg['gatewayId'] = gatewayId
			node_status_msg['nodeId'] = nodeId
			node_status_msg['preferredParentId'] = preferredParentId
			node_status_msg['requestId'] =2122
			node_status_msg['rank'] =decoded_response[36] + (decoded_response[37]<<8)
			node_status_msg['numberOfNeighbours'] = no_of_neighbors
			node_status_msg['batteryVoltage'] = decoded_response[6]
			
			neighbours=[]
			# add neighbour node 1 
			for i in range(no_of_neighbors):
				offset = i*16
				nnode={}
				nnode['nodeId']= decoded_response[44 + offset]
				nnode['etx']= decoded_response[50 + offset] + (decoded_response[51 + offset]<<8)
				nnode['rssi']= decoded_response[46 + offset]
				nnode['packetsTransmitted']= decoded_response[52 + offset] + (decoded_response[53 + offset]<<8) + (decoded_response[54 + offset]<<16) + (decoded_response[55 + offset]<<24)
				nnode['packetsSuccessfullySent']= decoded_response[56 + offset] + (decoded_response[57 + offset]<<8) + (decoded_response[58 + offset]<<16) + (decoded_response[59 + offset]<<24)
				neighbours.append(nnode)
			
			node_status_msg['neighbours'] =neighbours
			
			transmitted_jsonData = json.dumps(node_status_msg)
			mqttc.publish(MQTT_topic_node_status_response_for_WSN_GUI, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);
			print("")
			print(transmitted_jsonData)
			with open('transmitted_JSONData_wsnNodeStatus.json', 'w') as f:
				json.dump(transmitted_jsonData, f)
			f.close()
			
			print ("Notification for node status limited sent to broker")			
			
			#this is for the complete node status reply
			management_responses_received_from_WSN = management_responses_received_from_WSN + 1
			#prepare the complete node status response
			node_status_response_msg=dict()
			node_status_response_msg['nodeId'] = nodeId
			node_status_response_msg['gatewayId'] = 0
			ts = time.time()	# ts is the time returned in seconds
			st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%dT%H:%M:%S+02:00')
			node_status_response_msg['statusTime'] = st	
				
			node_status_response_msg['nodeLocation'] = dict()
			node_status_response_msg['nodeLocation']['latitude'] = 40.568002		
			node_status_response_msg['nodeLocation']['longitude'] = 23.104144
		
			node_status_response_msg['operationalStatus'] = decoded_response[4]
			node_status_response_msg['requestId'] = requestId
			if (full_status_response_indication ==1):
				node_status_response_msg['fullStatus'] = 1
				node_status_response_msg['storageLevel'] = decoded_response[14] + (decoded_response[15]<<8)
				node_status_response_msg['energyLevel'] = decoded_response[6]
				node_status_response_msg['netInterfaceStatus'] = decoded_response[3]
				if (nodeId == 2):
					node_status_response_msg['ipPktsRx'] = decoded_response[20] + (decoded_response[21]<<8) + (decoded_response[22]<<16) + (decoded_response[23]<<24)
					node_status_response_msg['ipPktsTx'] = alert_items_sent[0] + evidence_items_sent[0]*378
				else:
					node_status_response_msg['ipPktsRx'] = evidence_items_sent[1]*1
					node_status_response_msg['ipPktsTx'] = alert_items_sent[1] + evidence_items_sent[1]*354
				node_status_response_msg['ipPktsLossRate'] = 0
				node_status_response_msg['preferParentNode'] = decoded_response[38] + (decoded_response[39]<<8)
				node_status_response_msg['numberNeighbourNode'] = decoded_response[7]
				node_status_response_msg['numberCollision'] = 0
				if (nodeId == 2):
					node_status_response_msg['alertsTx'] = alert_items_sent[0]
					node_status_response_msg['evidencesTx'] = evidence_items_sent[0]
				else:
					node_status_response_msg['alertsTx'] = alert_items_sent[1]
					node_status_response_msg['evidencesTx'] = evidence_items_sent[1]
						
			else:
				node_status_response_msg['fullStatus'] = 0
		
			#prepare the json message and publish it
			#json.dumps() method turns a Python data structure into JSON:
			transmitted_jsonData = json.dumps(node_status_response_msg)
			print("the published JSON data for complete node status response are:")
			print("")
			print(transmitted_jsonData)
			with open('transmitted_JSONData_node_status_response.json', 'w') as f:
				json.dump(transmitted_jsonData, f)
			f.close()
			mqttc.publish(MQTT_topic_node_status_response, payload=transmitted_jsonData, qos=MQTT_qos_level, retain=False);
					
			print("")
			print ("Notification for node status complete sent to broker")
			
			
			
			